/****************************************************************************
 * Copyright (c) 2022 Andrey Sikorin.                                       *
 *                                                                          *
 * This program is free software: you can redistribute it and/or modify     *
 * it under the terms of the GNU General Public License as published by     *
 * the Free Software Foundation, version 3.                                 *
 *                                                                          *
 * This program is distributed in the hope that it will be useful, but      *
 * WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU         *
 * General Public License for more details.                                 *
 *                                                                          *
 * You should have received a copy of the GNU General Public License        *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.     *
 ****************************************************************************/

/**
 * @file scanner.c
 *
 * @brief Get user input via GNU readline library and split it into tokens.
 */

#include "scanner.h"

#include <stdio.h>
#include <stdlib.h>

// Including GNU readline library.
#include <readline.h>
#include <history.h>

#include "prompt.h"
#include "utility.h"

/**
 * @brief Used to return on fail in tokenize().
 */
static const struct Tokens INVALID_TOKENS = {INVALID, NULL, 0};

/**
 * @brief Frees Tokens structure and C-style string generated by GNU readline.
 *
 * @details Used in exceptional cases in the tokenize() function.
 *
 * @param[in] string The string that was read from the user.
 * @param[in] tokens Tokens that was spilled from string.
 */
static void free_resources(char* string, struct Tokens tokens) {
    rl_free(string);
    free_tokens(tokens);
}

/**
 * @brief Split string into Tokens structure.
 *
 * @param[in] string The string to tokenize.
 *
 * @return A struct Tokens.
 */
static struct Tokens tokenize(char* string) {
    struct Tokens tokens = {VALID, NULL, 0};

    char* tok = strtok(string, " \t\n");

    while (tok) {
        tokens.data = realloc(tokens.data, (tokens.amount + 1) * sizeof(char*));
        if (!check_alloc(tokens.data, "tokens")) {
            free_resources(string, tokens);
            return INVALID_TOKENS;
        }

        size_t extra_len = 0;
        if (tok[0] == '~') {
            extra_len = strlen(check_getenv("HOME"));
        } else if (tok[0] == '$' && getenv(tok + 1)) {
            extra_len = strlen(getenv(tok + 1));
        }
        tokens.data[tokens.amount] = malloc(strlen(tok) + extra_len + 1);
        if (!check_alloc(tokens.data, "token")) {
            free_resources(string, tokens);
            return INVALID_TOKENS;
        }

        if (tok[0] == '~') {
            strcpy(tokens.data[tokens.amount], getenv("HOME"));
            strcat(tokens.data[tokens.amount], tok + 1);
        } else if (tok[0] == '$' && extra_len) {
            strcpy(tokens.data[tokens.amount], getenv(tok + 1));
        } else {
            strcpy(tokens.data[tokens.amount], tok);
        }
        tokens.amount++;

        tok = strtok(NULL, " \t\n");
    }

    rl_free(string);
    return tokens;
}

/**
 * @brief Determine if user input content only whitespace characters.
 *
 * @param[in] string The string to check.
 *
 * @return Returns true if the string contains only whitespace.
 */
static bool is_skip(const char* string) {
    // EOF check
    if (!string) {
        putchar('\n');
        exit(EXIT_SUCCESS);
    }
    while (isspace(*string)) {
        ++string;
    }
    return *string == '\0';
}

struct Tokens input(void) {
    char* string = NULL;

    while (true) {
        char* prompt = get_prompt();
        string = readline(prompt);
        free(prompt);

        if (!is_skip(string)) {
            break;
        }
        rl_free(string);
    }
    add_history(string);

    return tokenize(string);
}

void free_tokens(struct Tokens tokens) {
    if (!tokens.data || tokens.state == INVALID) {
        return;
    }
    for (size_t i = 0; i < tokens.amount; ++i) {
        free(tokens.data[i]);
    }
    free(tokens.data);
}
